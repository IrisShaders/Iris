#version 450
#if defined(GL_EXT_control_flow_attributes)
#extension GL_EXT_control_flow_attributes : require
#define SPIRV_CROSS_FLATTEN [[flatten]]
#define SPIRV_CROSS_BRANCH [[dont_flatten]]
#define SPIRV_CROSS_UNROLL [[unroll]]
#define SPIRV_CROSS_LOOP [[dont_unroll]]
#else
#define SPIRV_CROSS_FLATTEN
#define SPIRV_CROSS_BRANCH
#define SPIRV_CROSS_UNROLL
#define SPIRV_CROSS_LOOP
#endif
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rg32f) uniform writeonly image2D gOutputMap;
uniform sampler2D reductionTex;

shared vec2 depthSamples[256];

void main()
{
    uvec2 igroup = min(((gl_WorkGroupID.xy * uvec2(16u)) + gl_LocalInvocationID.xy), (uvec2(textureSize(reductionTex, 0)) - uvec2(1u)));
    float depth = texelFetch(reductionTex, ivec2(igroup), int(0u)).x;
    depthSamples[gl_LocalInvocationIndex] = vec2((depth == 0.0) ? 1.0 : depth, texelFetch(reductionTex, ivec2(igroup), int(0u)).y);
    barrier();
    SPIRV_CROSS_UNROLL
    for (uint i = 128u; i > 0u; i = i >> 1u)
    {
        if (gl_LocalInvocationIndex < i)
        {
            uint index = gl_LocalInvocationIndex + i;
            depthSamples[gl_LocalInvocationIndex].x = isnan(depthSamples[index].x) ? depthSamples[gl_LocalInvocationIndex].x : (isnan(depthSamples[gl_LocalInvocationIndex].x) ? depthSamples[index].x : min(depthSamples[gl_LocalInvocationIndex].x, depthSamples[index].x));
            depthSamples[gl_LocalInvocationIndex].y = isnan(depthSamples[index].y) ? depthSamples[gl_LocalInvocationIndex].y : (isnan(depthSamples[gl_LocalInvocationIndex].y) ? depthSamples[index].y : max(depthSamples[gl_LocalInvocationIndex].y, depthSamples[index].y));
        }
        barrier();
    }
    if (gl_LocalInvocationIndex == 0u)
    {
        imageStore(gOutputMap, ivec2(gl_WorkGroupID.xy), vec2(depthSamples[0].x, depthSamples[0].y).xyyy);
    }
}

